@precedence { childRe @left, childDe @left, parentRe @left, parentDe @left, typeEnumIdent @left, typeSymbol @left, typeUnion @left, typeAtomic @left, arrayOf @left, type @left, trueFalseNull @left, objectKeySymbol @left, ident @left, symbol @left }

@top root { entity (redent entity)* }

entity { Model | Enum | TypeAlias | Function }

modelBody {indent modelChild (!parentRe redent (!ident modelChild))* !parentDe dedent }
ModelName { identifier }
Model { ModelName ((!symbol atomicValue) | mixin)* modelBody? }
mixin { "&" TypeSymbol }

modelChild { Field | describer }

FieldName { !ident identifier }
Field { FieldName typeSpec? LabelString? exampleSpec? fieldBody?  }
fieldBody { indent fieldChild (!childRe redent fieldChild)* !childDe dedent }
fieldChild { describer | typeSpec | contextualTypeSpec | LabelString | exampleSpec }

EnumName { identifier }
EnumPipe { pipe }
Enum { EnumPipe EnumName typeSpec? enumBody? }
enumBody { indent enumChild (!parentRe redent enumChild)* !parentDe dedent }
enumChild { Variant | describer | typeSpec }

VariantName { identifier }
Variant { VariantName (payloadSpec | equalSpec)? variantBody? }
variantBody { indent variantChild (!childRe redent variantChild)* !childDe dedent }
variantChild { describer | equalSpec }
payloadSpec { ParenOpen nonEnumType (comma nonEnumType)* comma? ParenClose }
equalSpec { Equal atomicValue }

FunctionName { identifier "()" }
Function { FunctionName functionBody? }
functionBody { indent functionChild (!parentRe redent (!ident functionChild))* !parentDe dedent }
functionChild { Field | returnField | describer }
returnField { RightArrow Field }

describer { singleDocumentationLine | multilineDocumentation | property | tags}
PropertyKey { identifier }
property { Period PropertyKey Equal value }
Tag { identifier }
tags { bracketOpen Tag (comma Tag)* comma? bracketClose }

exampleSpec { Tilde value }
typeSpec {  colon Type }
Type { typeInner  }
typeInner { !typeAtomic atomicType | !typeUnion unionType | !arrayOf arrayOfType | mapType }
mapType { TypeCurlyOpen atomicType colon typeInner TypeCurlyClose }
arrayOfType { TypeBracketOpen !type typeInner TypeBracketClose }
nonUnionType { atomicType | arrayOfType }
unionType { nonUnionType (TypePipe nonUnionType)* }
atomicType { !typeSymbol TypeSymbol | !typeEnumIdent typeEnumShorthand }
TypeContext { identifier }
contextualTypeSpec { ParenOpen TypeContext ParenClose typeSpec }
TypePipe { pipe }
TypeBracketOpen { bracketOpen }
TypeBracketClose { bracketClose }
TypeCurlyOpen { curlyOpen }
TypeCurlyClose { curlyClose }


nonEnumType { !typeAtomic TypeSymbol | !typeUnion nonEnumUnionType | !arrayOf nonEnumArrayOfType }
nonEnumArrayOfType { TypeBracketOpen !type nonEnumType TypeBracketClose }
nonEnumNonUnionType { TypeSymbol | nonEnumArrayOfType }
nonEnumUnionType { nonEnumNonUnionType (TypePipe nonEnumNonUnionType)* }

TypeSymbol { identifier }
typeEnumShorthand {  TypeEnumVariant comma TypeEnumVariant (comma TypeEnumVariant)* }
TypeEnumVariant { identifier }

TypeAlias { colon TypeAliasName Equal Type typeAliasBody? }
TypeAliasName { identifier }
typeAliasBody { indent describer (redent describer)* dedent }

value { complexValue }
atomicValue { ValueString | Bool | Null | Number | Symbol | Template }
complexValue {  Array | Object | atomicValue }
@skip { whitespace } {
    Object { curlyOpen objectKeyValue (',' objectKeyValue)* ','? curlyClose }
    Array { bracketOpen complexValue (',' complexValue)* ','? bracketClose }
}
objectKeyValue { (ObjectKeyString | ObjectKeySymbol) ':' complexValue }
ObjectKeyString { doubleQuoteString }
ObjectKeySymbol { identifier }
ValueString { doubleQuoteString }

Symbol { identifier }
Bool { true | false  }
true { @extend<identifier, "true"> }
false { @extend<identifier, "false"> }
Null { @extend<identifier, "null"> }

TemplateField { identifier }
templateParameter {AngleOpen TemplateField typeSpec? (Tilde ValueString)? AngleClose }

multilineDocumentation { DoubleCaret indent DocumentationString (redent DocumentationString)* dedent }
singleDocumentationLine { SingleDocumentationCaret DocumentationString }

@skip {} {
    LabelString { "'" (Escape | labelStringContent)* "'" }
    doubleQuoteString { "\"" (Escape | valueStringContent)* "\"" }
    Template { Backtick (Backtick | ((templateStringContent | templateParameter | Escape)+ Backtick)) }
    DocumentationString { documentationString }
}

SingleDocumentationCaret { singleCaret }


@external tokens indentation from "./tokens.js" {
    indent
    redent
    dedent
}


@skip { spaces }

AngleClose { singleCaret }

@tokens {
    identifier { $[a-zA-Z] $[a-zA-Z0-9\-_]* }
    spaces { $[ \t] }
    whitespace { $[ \n\r\t] }
    documentationString { ![^\n\r]+ }
    labelStringContent{ !['\\]+ }
    valueStringContent { !["\\]+ }
    templateStringContent { ![`\\<]+ }
    colon { ":" }
    comma { "," }
    Tilde { "~" }
    Backtick { "`" }
    pipe { "|" }
    Period { "." }
    bracketOpen { "[" }
    bracketClose { "]" }
    DoubleCaret { ">>" }
    AngleOpen { "<" }
    singleCaret { ">" }
    ParenOpen { "(" }
    ParenClose { ")" }
    curlyOpen { "{" }
    curlyClose { "}" }
    Equal { "=" }
    RightArrow { "->" }
    hex { @digit | $[a-fA-F] }
    Escape { "\\" ($["\\\/bfnrt`<'] | "u" hex hex hex hex hex ) }
    @precedence { documentationString, spaces }
    int  { '0' | $[1-9] @digit* }
    frac { '.' @digit+ }
    Number { '-'? int frac? exp? }
    exp  { $[eE] $[+\-]? @digit+ }
}


@context trackIndent from "./tokens.js"

@external propSource automnHighlighting from "./highlight.js"
